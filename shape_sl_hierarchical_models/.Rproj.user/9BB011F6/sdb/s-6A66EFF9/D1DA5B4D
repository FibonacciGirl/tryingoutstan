{
    "collab_server" : "",
    "contents" : "# Utility programs for use with the book,\n#   Kruschke, J. K. (2015). Doing Bayesian Data Analysis, Second Edition: \n#   A Tutorial with R, JAGS, and Stan. Academic Press / Elsevier.\n# This file contains several functions that are called by other programs\n# or can be called directly by the user. To load all the functions into\n# R's working memory, at R's command line type:\n# source(\"DBDA2E-utilities.R\")\n\n#------------------------------------------------------------------------------\n\nbookInfo = \"Kruschke, J. K. (2015). Doing Bayesian Data Analysis, Second Edition:\\nA Tutorial with R, JAGS, and Stan. Academic Press / Elsevier.\"\nbannerBreak = \"\\n*********************************************************************\\n\"\ncat(paste0(bannerBreak,bookInfo,bannerBreak,\"\\n\"))\n\n#------------------------------------------------------------------------------\n# Check that required packages are installed:\nwant = c(\"parallel\",\"rjags\",\"runjags\",\"compute.es\")\nhave = want %in% rownames(installed.packages())\nif ( any(!have) ) { install.packages( want[!have] ) }\n\n# Load rjags. Assumes JAGS is already installed.\ntry( library(rjags) )\n# Load runjags. Assumes JAGS is already installed.\ntry( library(runjags) )\ntry( runjags.options( inits.warning=FALSE , rng.warning=FALSE ) )\n\n# set default number of chains and parallelness for MCMC:\nlibrary(parallel) # for detectCores().\nnCores = detectCores() \nif ( !is.finite(nCores) ) { nCores = 1 } \nif ( nCores > 4 ) { \n  nChainsDefault = 4  # because JAGS has only 4 rng's.\n  runjagsMethodDefault = \"parallel\"\n}\nif ( nCores == 4 ) { \n  nChainsDefault = 3  # save 1 core for other processes.\n  runjagsMethodDefault = \"parallel\"\n}\nif ( nCores < 4 ) { \n  nChainsDefault = 3 \n  runjagsMethodDefault = \"rjags\" # NOT parallel\n}\n\n#------------------------------------------------------------------------------\n# Functions for opening and saving graphics that operate the same for \n# Windows and Macintosh and Linux operating systems. At least, that's the hope!\n\nopenGraph = function( width=7 , height=7 , mag=1.0 , ... ) {\n  if ( .Platform$OS.type != \"windows\" ) { # Mac OS, Linux\n    tryInfo = try( X11( width=width*mag , height=height*mag , type=\"cairo\" , \n                        ... ) )\n    if ( class(tryInfo)==\"try-error\" ) {\n      lineInput = readline(\"WARNING: Previous graphics windows will be closed because of too many open windows.\\nTO CONTINUE, PRESS <ENTER> IN R CONSOLE.\\n\")\n      graphics.off() \n      X11( width=width*mag , height=height*mag , type=\"cairo\" , ... )\n    }\n  } else { # Windows OS\n    tryInfo = try( windows( width=width*mag , height=height*mag , ... ) )\n    if ( class(tryInfo)==\"try-error\" ) {\n      lineInput = readline(\"WARNING: Previous graphics windows will be closed because of too many open windows.\\nTO CONTINUE, PRESS <ENTER> IN R CONSOLE.\\n\")\n      graphics.off() \n      windows( width=width*mag , height=height*mag , ... )    \n    }\n  }\n}\n\nsaveGraph = function( file=\"saveGraphOutput\" , type=\"pdf\" , ... ) {\n  if ( .Platform$OS.type != \"windows\" ) { # Mac OS, Linux\n    if ( any( type == c(\"png\",\"jpeg\",\"jpg\",\"tiff\",\"bmp\")) ) {\n      sptype = type\n      if ( type == \"jpg\" ) { sptype = \"jpeg\" }\n      savePlot( file=paste0(file,\".\",type) , type=sptype , ... )     \n    }\n    if ( type == \"pdf\" ) {\n      dev.copy2pdf(file=paste0(file,\".\",type) , ... )\n    }\n    if ( type == \"eps\" ) {\n      dev.copy2eps(file=paste0(file,\".\",type) , ... )\n    }\n  } else { # Windows OS\n    file=paste0(file,\".\",type) \n    savePlot( file=file , type=type , ... )\n  }\n}\n\n#------------------------------------------------------------------------------\n# Functions for computing limits of HDI's:\n\nHDIofMCMC = function( sampleVec , credMass=0.95 ) {\n  # Computes highest density interval from a sample of representative values,\n  #   estimated as shortest credible interval.\n  # Arguments:\n  #   sampleVec\n  #     is a vector of representative values from a probability distribution.\n  #   credMass\n  #     is a scalar between 0 and 1, indicating the mass within the credible\n  #     interval that is to be estimated.\n  # Value:\n  #   HDIlim is a vector containing the limits of the HDI\n  sortedPts = sort( sampleVec )\n  ciIdxInc = ceiling( credMass * length( sortedPts ) )\n  nCIs = length( sortedPts ) - ciIdxInc\n  ciWidth = rep( 0 , nCIs )\n  for ( i in 1:nCIs ) {\n    ciWidth[ i ] = sortedPts[ i + ciIdxInc ] - sortedPts[ i ]\n  }\n  HDImin = sortedPts[ which.min( ciWidth ) ]\n  HDImax = sortedPts[ which.min( ciWidth ) + ciIdxInc ]\n  HDIlim = c( HDImin , HDImax )\n  return( HDIlim )\n}\n\nHDIofICDF = function( ICDFname , credMass=0.95 , tol=1e-8 , ... ) {\n  # Arguments:\n  #   ICDFname is R's name for the inverse cumulative density function\n  #     of the distribution.\n  #   credMass is the desired mass of the HDI region.\n  #   tol is passed to R's optimize function.\n  # Return value:\n  #   Highest density iterval (HDI) limits in a vector.\n  # Example of use: For determining HDI of a beta(30,12) distribution, type\n  #   HDIofICDF( qbeta , shape1 = 30 , shape2 = 12 )\n  #   Notice that the parameters of the ICDFname must be explicitly named;\n  #   e.g., HDIofICDF( qbeta , 30 , 12 ) does not work.\n  # Adapted and corrected from Greg Snow's TeachingDemos package.\n  incredMass =  1.0 - credMass\n  intervalWidth = function( lowTailPr , ICDFname , credMass , ... ) {\n    ICDFname( credMass + lowTailPr , ... ) - ICDFname( lowTailPr , ... )\n  }\n  optInfo = optimize( intervalWidth , c( 0 , incredMass ) , ICDFname=ICDFname ,\n                      credMass=credMass , tol=tol , ... )\n  HDIlowTailPr = optInfo$minimum\n  return( c( ICDFname( HDIlowTailPr , ... ) ,\n             ICDFname( credMass + HDIlowTailPr , ... ) ) )\n}\n\nHDIofGrid = function( probMassVec , credMass=0.95 ) {\n  # Arguments:\n  #   probMassVec is a vector of probability masses at each grid point.\n  #   credMass is the desired mass of the HDI region.\n  # Return value:\n  #   A list with components:\n  #   indices is a vector of indices that are in the HDI\n  #   mass is the total mass of the included indices\n  #   height is the smallest component probability mass in the HDI\n  # Example of use: For determining HDI of a beta(30,12) distribution\n  #   approximated on a grid:\n  #   > probDensityVec = dbeta( seq(0,1,length=201) , 30 , 12 )\n  #   > probMassVec = probDensityVec / sum( probDensityVec )\n  #   > HDIinfo = HDIofGrid( probMassVec )\n  #   > show( HDIinfo )\n  sortedProbMass = sort( probMassVec , decreasing=TRUE )\n  HDIheightIdx = min( which( cumsum( sortedProbMass ) >= credMass ) )\n  HDIheight = sortedProbMass[ HDIheightIdx ]\n  HDImass = sum( probMassVec[ probMassVec >= HDIheight ] )\n  return( list( indices = which( probMassVec >= HDIheight ) ,\n                mass = HDImass , height = HDIheight ) )\n}\n\n#------------------------------------------------------------------------------\n# Function(s) for plotting properties of mcmc coda objects.\n\nDbdaAcfPlot = function( codaObject , parName=varnames(codaObject)[1] , plColors=NULL ) {\n  if ( all( parName != varnames(codaObject) ) ) { \n    stop(\"parName must be a column name of coda object\")\n  }\n  nChain = length(codaObject)\n  if ( is.null(plColors) ) plColors=1:nChain\n  xMat = NULL\n  yMat = NULL\n  for ( cIdx in 1:nChain ) {\n    acfInfo = acf(codaObject[,c(parName)][[cIdx]],plot=FALSE) \n    xMat = cbind(xMat,acfInfo$lag)\n    yMat = cbind(yMat,acfInfo$acf)\n  }\n  matplot( xMat , yMat , type=\"o\" , pch=20 , col=plColors , ylim=c(0,1) ,\n           main=\"\" , xlab=\"Lag\" , ylab=\"Autocorrelation\" )\n  abline(h=0,lty=\"dashed\")\n  EffChnLngth = effectiveSize(codaObject[,c(parName)])\n  text( x=max(xMat) , y=max(yMat) , adj=c(1.0,1.0) , cex=1.25 ,\n        labels=paste(\"ESS =\",round(EffChnLngth,1)) )\n}\n\nDbdaDensPlot = function( codaObject , parName=varnames(codaObject)[1] , plColors=NULL ) {\n  if ( all( parName != varnames(codaObject) ) ) { \n    stop(\"parName must be a column name of coda object\")\n  }\n  nChain = length(codaObject) # or nchain(codaObject)\n  if ( is.null(plColors) ) plColors=1:nChain\n  xMat = NULL\n  yMat = NULL\n  hdiLims = NULL\n  for ( cIdx in 1:nChain ) {\n    densInfo = density(codaObject[,c(parName)][[cIdx]]) \n    xMat = cbind(xMat,densInfo$x)\n    yMat = cbind(yMat,densInfo$y)\n    hdiLims = cbind(hdiLims,HDIofMCMC(codaObject[,c(parName)][[cIdx]]))\n  }\n  matplot( xMat , yMat , type=\"l\" , col=plColors , \n           main=\"\" , xlab=\"Param. Value\" , ylab=\"Density\" )\n  abline(h=0)\n  points( hdiLims[1,] , rep(0,nChain) , col=plColors , pch=\"|\" )\n  points( hdiLims[2,] , rep(0,nChain) , col=plColors , pch=\"|\" )\n  text( mean(hdiLims) , 0 , \"95% HDI\" , adj=c(0.5,-0.2) )\n  EffChnLngth = effectiveSize(codaObject[,c(parName)])\n  MCSE = sd(as.matrix(codaObject[,c(parName)]))/sqrt(EffChnLngth) \n  text( max(xMat) , max(yMat) , adj=c(1.0,1.0) , cex=1.25 ,\n        paste(\"MCSE =\\n\",signif(MCSE,3)) )\n}\n\ndiagMCMC = function( codaObject , parName=varnames(codaObject)[1] ,\n                     saveName=NULL , saveType=\"jpg\" ) {\n  DBDAplColors = c(\"skyblue\",\"black\",\"royalblue\",\"steelblue\")\n  openGraph(height=5,width=7)\n  par( mar=0.5+c(3,4,1,0) , oma=0.1+c(0,0,2,0) , mgp=c(2.25,0.7,0) , \n       cex.lab=1.5 )\n  layout(matrix(1:4,nrow=2))\n  # traceplot and gelman.plot are from CODA package:\n  require(coda)\n  coda::traceplot( codaObject[,c(parName)] , main=\"\" , ylab=\"Param. Value\" ,\n                   col=DBDAplColors ) \n  tryVal = try(\n    coda::gelman.plot( codaObject[,c(parName)] , main=\"\" , auto.layout=FALSE , \n                       col=DBDAplColors )\n  )  \n  # if it runs, gelman.plot returns a list with finite shrink values:\n  if ( class(tryVal)==\"try-error\" ) {\n    plot.new() \n    print(paste0(\"Warning: coda::gelman.plot fails for \",parName))\n  } else { \n    if ( class(tryVal)==\"list\" & !is.finite(tryVal$shrink[1]) ) {\n      plot.new() \n      print(paste0(\"Warning: coda::gelman.plot fails for \",parName))\n    }\n  }\n  DbdaAcfPlot(codaObject,parName,plColors=DBDAplColors)\n  DbdaDensPlot(codaObject,parName,plColors=DBDAplColors)\n  mtext( text=parName , outer=TRUE , adj=c(0.5,0.5) , cex=2.0 )\n  if ( !is.null(saveName) ) {\n    saveGraph( file=paste0(saveName,\"Diag\",parName), type=saveType)\n  }\n}\n\ndiagStanFit = function( stanFit , parName ,\n                        saveName=NULL , saveType=\"jpg\" ) {\n  codaFit = mcmc.list( lapply( 1:ncol(stanFit) , \n                               function(x) { mcmc(as.array(stanFit)[,x,]) } ) )\n  DBDAplColors = c(\"skyblue\",\"black\",\"royalblue\",\"steelblue\")\n  openGraph(height=5,width=7)\n  par( mar=0.5+c(3,4,1,0) , oma=0.1+c(0,0,2,0) , mgp=c(2.25,0.7,0) , cex.lab=1.5 )\n  layout(matrix(1:4,nrow=2))\n  # traceplot is from rstan package\n  require(rstan)\n  traceplot(stanFit,pars=parName,nrow=1,ncol=1)#,main=\"\",ylab=\"Param. Value\",col=DBDAplColors) \n  # gelman.plot are from CODA package:\n  require(coda)\n  tryVal = try(\n    coda::gelman.plot( codaObject[,c(parName)] , main=\"\" , auto.layout=FALSE , \n                       col=DBDAplColors )\n  )\n  # if it runs, gelman.plot returns a list with finite shrink values:\n  if ( class(tryVal)==\"try-error\" ) {\n    plot.new() \n    print(paste0(\"Warning: coda::gelman.plot fails for \",parName))\n  } else { \n    if ( class(tryVal)==\"list\" & !is.finite(tryVal$shrink[1]) ) {\n      plot.new() \n      print(paste0(\"Warning: coda::gelman.plot fails for \",parName))\n    }\n  }\n  DbdaAcfPlot(codaFit,parName,plColors=DBDAplColors)\n  DbdaDensPlot(codaFit,parName,plColors=DBDAplColors)\n  mtext( text=parName , outer=TRUE , adj=c(0.5,0.5) , cex=2.0 )\n  if ( !is.null(saveName) ) {\n    saveGraph( file=paste0(saveName,\"Diag\",parName), type=saveType)\n  }\n}\n\n#------------------------------------------------------------------------------\n# Functions for summarizing and plotting distribution of a large sample; \n# typically applied to MCMC posterior.\n\nnormalize = function( v ){ return( v / sum(v) ) }\n\nrequire(coda) # loaded by rjags, but redundancy doesn't hurt\n\nsummarizePost = function( paramSampleVec , \n                          compVal=NULL , ROPE=NULL , credMass=0.95 ) {\n  meanParam = mean( paramSampleVec )\n  medianParam = median( paramSampleVec )\n  dres = density( paramSampleVec )\n  modeParam = dres$x[which.max(dres$y)]\n  mcmcEffSz = round( effectiveSize( paramSampleVec ) , 1 )\n  names(mcmcEffSz) = NULL\n  hdiLim = HDIofMCMC( paramSampleVec , credMass=credMass )\n  if ( !is.null(compVal) ) {\n    pcgtCompVal = ( 100 * sum( paramSampleVec > compVal ) \n                    / length( paramSampleVec ) )\n  } else {\n    compVal=NA\n    pcgtCompVal=NA\n  }\n  if ( !is.null(ROPE) ) {\n    pcltRope = ( 100 * sum( paramSampleVec < ROPE[1] ) \n                 / length( paramSampleVec ) )\n    pcgtRope = ( 100 * sum( paramSampleVec > ROPE[2] ) \n                 / length( paramSampleVec ) )\n    pcinRope = 100-(pcltRope+pcgtRope)\n  } else { \n    ROPE = c(NA,NA)\n    pcltRope=NA \n    pcgtRope=NA \n    pcinRope=NA \n  }  \n  return( c( Mean=meanParam , Median=medianParam , Mode=modeParam , \n             ESS=mcmcEffSz ,\n             HDImass=credMass , HDIlow=hdiLim[1] , HDIhigh=hdiLim[2] , \n             CompVal=compVal , PcntGtCompVal=pcgtCompVal , \n             ROPElow=ROPE[1] , ROPEhigh=ROPE[2] ,\n             PcntLtROPE=pcltRope , PcntInROPE=pcinRope , PcntGtROPE=pcgtRope ) )\n}\n\nplotPost = function( paramSampleVec , cenTend=c(\"mode\",\"median\",\"mean\")[1] , \n                     compVal=NULL, ROPE=NULL, credMass=0.95, HDItextPlace=0.7, \n                     xlab=NULL , xlim=NULL , yaxt=NULL , ylab=NULL , \n                     main=NULL , cex=NULL , cex.lab=NULL ,\n                     col=NULL , border=NULL , showCurve=FALSE , breaks=NULL , \n                     ... ) {\n  # Override defaults of hist function, if not specified by user:\n  # (additional arguments \"...\" are passed to the hist function)\n  if ( is.null(xlab) ) xlab=\"Param. Val.\"\n  if ( is.null(cex.lab) ) cex.lab=1.5\n  if ( is.null(cex) ) cex=1.4\n  if ( is.null(xlim) ) xlim=range( c( compVal , ROPE , paramSampleVec ) )\n  if ( is.null(main) ) main=\"\"\n  if ( is.null(yaxt) ) yaxt=\"n\"\n  if ( is.null(ylab) ) ylab=\"\"\n  if ( is.null(col) ) col=\"skyblue\"\n  if ( is.null(border) ) border=\"white\"\n  \n  # convert coda object to matrix:\n  if ( class(paramSampleVec) == \"mcmc.list\" ) {\n    paramSampleVec = as.matrix(paramSampleVec)\n  }\n  \n  summaryColNames = c(\"ESS\",\"mean\",\"median\",\"mode\",\n                      \"hdiMass\",\"hdiLow\",\"hdiHigh\",\n                      \"compVal\",\"pGtCompVal\",\n                      \"ROPElow\",\"ROPEhigh\",\"pLtROPE\",\"pInROPE\",\"pGtROPE\")\n  postSummary = matrix( NA , nrow=1 , ncol=length(summaryColNames) , \n                        dimnames=list( c( xlab ) , summaryColNames ) )\n  \n  # require(coda) # for effectiveSize function\n  postSummary[,\"ESS\"] = effectiveSize(paramSampleVec)\n  \n  postSummary[,\"mean\"] = mean(paramSampleVec)\n  postSummary[,\"median\"] = median(paramSampleVec)\n  mcmcDensity = density(paramSampleVec)\n  postSummary[,\"mode\"] = mcmcDensity$x[which.max(mcmcDensity$y)]\n  \n  HDI = HDIofMCMC( paramSampleVec , credMass )\n  postSummary[,\"hdiMass\"]=credMass\n  postSummary[,\"hdiLow\"]=HDI[1]\n  postSummary[,\"hdiHigh\"]=HDI[2]\n  \n  # Plot histogram.\n  cvCol = \"darkgreen\"\n  ropeCol = \"darkred\"\n  if ( is.null(breaks) ) {\n    if ( max(paramSampleVec) > min(paramSampleVec) ) {\n      breaks = c( seq( from=min(paramSampleVec) , to=max(paramSampleVec) ,\n                       by=(HDI[2]-HDI[1])/18 ) , max(paramSampleVec) )\n    } else {\n      breaks=c(min(paramSampleVec)-1.0E-6,max(paramSampleVec)+1.0E-6)\n      border=\"skyblue\"\n    }\n  }\n  if ( !showCurve ) {\n    par(xpd=NA)\n    histinfo = hist( paramSampleVec , xlab=xlab , yaxt=yaxt , ylab=ylab ,\n                     freq=F , border=border , col=col ,\n                     xlim=xlim , main=main , cex=cex , cex.lab=cex.lab ,\n                     breaks=breaks , ... )\n  }\n  if ( showCurve ) {\n    par(xpd=NA)\n    histinfo = hist( paramSampleVec , plot=F )\n    densCurve = density( paramSampleVec , adjust=2 )\n    plot( densCurve$x , densCurve$y , type=\"l\" , lwd=5 , col=col , bty=\"n\" ,\n          xlim=xlim , xlab=xlab , yaxt=yaxt , ylab=ylab ,\n          main=main , cex=cex , cex.lab=cex.lab , ... )\n  }\n  cenTendHt = 0.9*max(histinfo$density)\n  cvHt = 0.7*max(histinfo$density)\n  ROPEtextHt = 0.55*max(histinfo$density)\n  # Display central tendency:\n  mn = mean(paramSampleVec)\n  med = median(paramSampleVec)\n  mcmcDensity = density(paramSampleVec)\n  mo = mcmcDensity$x[which.max(mcmcDensity$y)]\n  if ( cenTend==\"mode\" ){ \n    text( mo , cenTendHt ,\n          bquote(mode==.(signif(mo,3))) , adj=c(.5,0) , cex=cex )\n  }\n  if ( cenTend==\"median\" ){ \n    text( med , cenTendHt ,\n          bquote(median==.(signif(med,3))) , adj=c(.5,0) , cex=cex , col=cvCol )\n  }\n  if ( cenTend==\"mean\" ){ \n    text( mn , cenTendHt ,\n          bquote(mean==.(signif(mn,3))) , adj=c(.5,0) , cex=cex )\n  }\n  # Display the comparison value.\n  if ( !is.null( compVal ) ) {\n    pGtCompVal = sum( paramSampleVec > compVal ) / length( paramSampleVec ) \n    pLtCompVal = 1 - pGtCompVal\n    lines( c(compVal,compVal) , c(0.96*cvHt,0) , \n           lty=\"dotted\" , lwd=2 , col=cvCol )\n    text( compVal , cvHt ,\n          bquote( .(round(100*pLtCompVal,1)) * \"% < \" *\n                   .(signif(compVal,3)) * \" < \" * \n                   .(round(100*pGtCompVal,1)) * \"%\" ) ,\n          adj=c(pLtCompVal,0) , cex=0.8*cex , col=cvCol )\n    postSummary[,\"compVal\"] = compVal\n    postSummary[,\"pGtCompVal\"] = pGtCompVal\n  }\n  # Display the ROPE.\n  if ( !is.null( ROPE ) ) {\n    pInROPE = ( sum( paramSampleVec > ROPE[1] & paramSampleVec < ROPE[2] )\n                / length( paramSampleVec ) )\n    pGtROPE = ( sum( paramSampleVec >= ROPE[2] ) / length( paramSampleVec ) )\n    pLtROPE = ( sum( paramSampleVec <= ROPE[1] ) / length( paramSampleVec ) )\n    lines( c(ROPE[1],ROPE[1]) , c(0.96*ROPEtextHt,0) , lty=\"dotted\" , lwd=2 ,\n           col=ropeCol )\n    lines( c(ROPE[2],ROPE[2]) , c(0.96*ROPEtextHt,0) , lty=\"dotted\" , lwd=2 ,\n           col=ropeCol)\n    text( mean(ROPE) , ROPEtextHt ,\n          bquote( .(round(100*pLtROPE,1)) * \"% < \" * .(ROPE[1]) * \" < \" * \n                   .(round(100*pInROPE,1)) * \"% < \" * .(ROPE[2]) * \" < \" * \n                   .(round(100*pGtROPE,1)) * \"%\" ) ,\n          adj=c(pLtROPE+.5*pInROPE,0) , cex=1 , col=ropeCol )\n    \n    postSummary[,\"ROPElow\"]=ROPE[1] \n    postSummary[,\"ROPEhigh\"]=ROPE[2] \n    postSummary[,\"pLtROPE\"]=pLtROPE\n    postSummary[,\"pInROPE\"]=pInROPE\n    postSummary[,\"pGtROPE\"]=pGtROPE\n  }\n  # Display the HDI.\n  lines( HDI , c(0,0) , lwd=4 , lend=1 )\n  text( mean(HDI) , 0 , bquote(.(100*credMass) * \"% HDI\" ) ,\n        adj=c(.5,-1.7) , cex=cex )\n  text( HDI[1] , 0 , bquote(.(signif(HDI[1],3))) ,\n        adj=c(HDItextPlace,-0.5) , cex=cex )\n  text( HDI[2] , 0 , bquote(.(signif(HDI[2],3))) ,\n        adj=c(1.0-HDItextPlace,-0.5) , cex=cex )\n  par(xpd=F)\n  #\n  return( postSummary )\n}\n\n#------------------------------------------------------------------------------\n\n# Shape parameters from central tendency and scale:\n\nbetaABfromMeanKappa = function( mean , kappa ) {\n  if ( mean <=0 | mean >= 1) stop(\"must have 0 < mean < 1\")\n  if ( kappa <=0 ) stop(\"kappa must be > 0\")\n  a = mean * kappa\n  b = ( 1.0 - mean ) * kappa\n  return( list( a=a , b=b ) )\n}\n\nbetaABfromModeKappa = function( mode , kappa ) {\n  if ( mode <=0 | mode >= 1) stop(\"must have 0 < mode < 1\")\n  if ( kappa <=2 ) stop(\"kappa must be > 2 for mode parameterization\")\n  a = mode * ( kappa - 2 ) + 1\n  b = ( 1.0 - mode ) * ( kappa - 2 ) + 1\n  return( list( a=a , b=b ) )\n}\n\nbetaABfromMeanSD = function( mean , sd ) {\n  if ( mean <=0 | mean >= 1) stop(\"must have 0 < mean < 1\")\n  if ( sd <= 0 ) stop(\"sd must be > 0\")\n  kappa = mean*(1-mean)/sd^2 - 1\n  if ( kappa <= 0 ) stop(\"invalid combination of mean and sd\")\n  a = mean * kappa\n  b = ( 1.0 - mean ) * kappa\n  return( list( a=a , b=b ) )\n}\n\ngammaShRaFromMeanSD = function( mean , sd ) {\n  if ( mean <=0 ) stop(\"mean must be > 0\")\n  if ( sd <=0 ) stop(\"sd must be > 0\")\n  shape = mean^2/sd^2\n  rate = mean/sd^2\n  return( list( shape=shape , rate=rate ) )\n}\n\ngammaShRaFromModeSD = function( mode , sd ) {\n  if ( mode <=0 ) stop(\"mode must be > 0\")\n  if ( sd <=0 ) stop(\"sd must be > 0\")\n  rate = ( mode + sqrt( mode^2 + 4 * sd^2 ) ) / ( 2 * sd^2 )\n  shape = 1 + mode * rate\n  return( list( shape=shape , rate=rate ) )\n}\n\n#------------------------------------------------------------------------------\n\n# Make some data files for examples...\ncreateDataFiles=FALSE\nif ( createDataFiles ) {\n  \n  source(\"HtWtDataGenerator.R\")\n  N=300\n  m = HtWtDataGenerator( N , rndsd=47405 )\n  write.csv( file=paste0(\"HtWtData\",N,\".csv\") , row.names=FALSE , m )\n  \n  \n  # Function for generating normal data with normal outliers:\n  genYwithOut = function( N , pcntOut=15 , sdOut=3.0 ) {\n    inl = rnorm( N-ceiling(pcntOut/100*N) )\n    out = rnorm(   ceiling(pcntOut/100*N) )\n    inl = (inl-mean(inl))/sd(inl)\n    out = (out-mean(out))/sd(out) * sdOut\n    return(c(inl,out))\n  }\n  \n  # Two-group IQ scores with outliers \n  set.seed(47405)\n  y1 = round(pmax(50,genYwithOut(63,20,3.5)*17.5+106))\n  y2 = round(pmax(50,genYwithOut(57,20,3.5)*10+100))\n  write.csv( file=\"TwoGroupIQ.csv\" , row.names=FALSE ,\n             data.frame( Score=c(y1,y2) , \n                         Group=c(rep(\"Smart Drug\",length(y1)),\n                                 rep(\"Placebo\",length(y2))) ) )\n  \n  # One-group log-normal\n  set.seed(47405)\n  z = rnorm(123)\n  logY = (z-mean(z))/sd(z) * 0.5 + 5.5 # logY has mean 5.5 and sd 0.5\n  y = round( exp(logY) , 2 )\n  write.csv( file=\"OneGroupLogNormal.csv\" , row.names=FALSE ,\n             cbind(y) )\n  \n  # One-group gamma\n  desiredMode = 250\n  desiredSD = 100\n  desiredRate = (desiredMode+sqrt(desiredMode^2+4*desiredSD^2))/(2*desiredSD^2)\n  desiredShape = 1+desiredMode*desiredRate\n  set.seed(47405)\n  y = round( rgamma( 153 , shape=desiredShape , rate=desiredRate ) , 2 )\n  write.csv( file=\"OneGroupGamma.csv\" , row.names=FALSE , cbind(y) )\n  \n} # end if createDataFiles\n",
    "created" : 1498746187649.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3270347611",
    "id" : "D1DA5B4D",
    "lastKnownWriteTime" : 1496322110,
    "last_content_update" : 1496322110,
    "path" : "~/GitHub/shape_of_sl/scripts/DBDA2E-utilities.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}