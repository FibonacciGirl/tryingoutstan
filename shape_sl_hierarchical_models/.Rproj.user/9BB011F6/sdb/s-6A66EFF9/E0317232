{
    "collab_server" : "",
    "contents" : "\nsource('model_predict.R')\nsource('DBDA2E-utilities.R')\n\n\nmodel.params<-function(fit,m){\n  \n  if(m == 'power.constant'){\n    params<- c(as.numeric(fit$power.constant$intercept),\n               as.numeric(fit$power.constant$base),\n               as.numeric(fit$power.constant$rate),\n               as.numeric(fit$power.constant$proportion),\n               as.numeric(fit$power.constant$sigma))\n  }\n  \n\n  \n  if(m == 'power.power'){\n    params<-c(as.numeric(fit$power.power$intercept),\n              as.numeric(fit$power.power$base),\n              as.numeric(fit$power.power$rate),\n              as.numeric(fit$power.power$proportion),\n              as.numeric(fit$power.power$base.1),\n              as.numeric(fit$power.power$rate.1),\n              as.numeric(fit$power.power$sigma))\n  }\n  if(m == 'piecewise.power.constant'){\n    params<-c(as.numeric(fit$piecewise.power.constant$intercept),\n              as.numeric(fit$piecewise.power.constant$base),\n              as.numeric(fit$piecewise.power.constant$rate),\n              as.numeric(fit$piecewise.power.constant$proportion),\n              as.numeric(fit$piecewise.power.constant$jump),\n              as.numeric(fit$piecewise.power.constant$split),\n              as.numeric(fit$piecewise.power.constant$sigma))\n  }\n  if(m == 'power.logistic'){\n    params<-c(as.numeric(fit$power.logistic$intercept),\n              as.numeric(fit$power.logistic$base),\n              as.numeric(fit$power.logistic$rate),\n              as.numeric(fit$power.logistic$upper.proportion),\n              as.numeric(fit$power.logistic$lower.proportion),\n              as.numeric(fit$power.logistic$rate.1),\n              as.numeric(fit$power.logistic$split),\n              as.numeric(fit$power.logistic$sigma))\n  }\n  return(params)\n}\n\n\n\nr.normal<- function(params){\n  mu<-params[1]\n  sd<-params[2]\n  return(rnorm(1, mean = mu , sd = sd))\n}\n\nr.gamma<- function(params){\n  a<-gammaShRaFromModeSD(params[1], params[2])$shape\n  b<-gammaShRaFromModeSD(params[1], params[2])$rate\n  return(rgamma(1, shape = a , rate = b))\n}\n\nr.beta<-function (params){\n  a<-params[1]\n  b<-params[2]\n  return(rbeta(1, a, b))\n}\n\nr.exp<-function(params){\n  return(rexp(1, params[1]))\n}\n\nr.unif<-function(params){\n  return(runif(1, params[1], params[2]))\n}\n\nr.pois<-function(params){\n  return(rpois(1, params[1]))\n}\n\nr.cat<-function(params){\n  return(rmultinom(1, 1, rep(params[1],params[2])))\n}\n\n\nr.prior.fn<- function(fn, params){\n  return(fn(params))\n}\n\n\nr.prior<-function(type, priors){\n  \n  if(type == 'intercept'){\n    fn <- priors$intercept$fn\n    params<- c(as.numeric(priors$intercept$par1), as.numeric(priors$intercept$par2))\n  }\n  if(type == 'base'){\n    fn <- priors$base$fn\n    params<- c(as.numeric(priors$base$par1), as.numeric(priors$base$par2))\n  }\n  if(type=='base.1'){\n    fn <- priors$base.1$fn\n    params<- c(as.numeric(priors$base.1$par1), as.numeric(priors$base.1$par2))\n  }\n  \n  if(type == 'rate' ){\n    fn <- priors$rate$fn\n    params<- c(as.numeric(priors$rate$par1), as.numeric(priors$rate$par2))\n  }\n  if(type == 'rate.1'){\n    fn <- priors$rate.1$fn\n    params<- c(as.numeric(priors$rate.1$par1), as.numeric(priors$rate.1$par2))\n  }\n  if(type == 'sigma'){\n    fn <- priors$sigma$fn\n    params<- c(as.numeric(priors$sigma$par1), as.numeric(priors$sigma$par2))\n  }\n  if(type == 'split'){\n    fn<- priors$split$fn\n    params<- c(as.numeric(priors$split$par1), as.numeric(priors$split$par2))\n  }\n  if(type == 'jump'){\n    fn <- priors$jump$fn\n    params<- c(as.numeric(priors$jump$par1), as.numeric(priors$jump$par2))\n  }\n  if(type == 'proportion'){\n    fn <- priors$proportion$fn\n    params<- c(as.numeric(priors$proportion$par1), as.numeric(priors$proportion$par2))\n  }\n  if(type == 'upper.proportion'){\n    fn <- priors$upper.proportion$fn\n    params<- c(as.numeric(priors$upper.proportion$par1), as.numeric(priors$upper.proportion$par2))\n  }\n  if(type == 'lower.proportion'){\n    fn <- priors$lower.proportion$fn\n    params<- c(as.numeric(priors$lower.proportion$par1), as.numeric(priors$lower.proportion$par2))\n  }\n  \n  \n  if(fn == 'normal'){\n    return(r.prior.fn(r.normal,params))\n  }\n  if(fn == 'gamma'){\n    return(r.prior.fn(r.gamma,params))\n  }\n  if(fn == 'beta'){\n    return(r.prior.fn(r.beta,params))\n  }\n  if(fn == 'exp'){\n    return(r.prior.fn(r.exp,params))\n  }\n  if(fn == 'unif'){\n    return(r.prior.fn(r.unif,params))\n  }\n  if(fn == 'pois'){\n    return(r.prior.fn(r.pois,params))\n  }\n  if(fn == 'cat'){\n    return(r.prior.fn(r.cat,params))\n  }\n}\n\n\ngenerate.parameter.values<-function(priors){\n  \n  \n  recovery.parameter.values<- list(\n    power.constant = list(intercept = r.prior('intercept',priors),\n                          base= r.prior('base',priors), \n                          rate= -r.prior('rate',priors),\n                          proportion = r.prior('proportion',priors),\n                          sigma=r.prior('sigma',priors)),\n   \n    piecewise.power.constant = list(intercept = r.prior('intercept',priors),\n                                    base= r.prior('base',priors), \n                                    rate= -r.prior('rate',priors),\n                                    proportion = r.prior('proportion',priors),\n                                    jump = r.prior('jump',priors),\n                                    split = r.prior('split',priors),\n                                    sigma=r.prior('sigma',priors)),\n    \n    power.power = list(intercept = r.prior('intercept',priors),\n                       base= r.prior('base',priors), \n                       rate= -r.prior('rate',priors),\n                       proportion = r.prior('proportion',priors), \n                       base.1= r.prior('base.1',priors), \n                       rate.1= -r.prior('rate.1',priors),\n                       sigma=r.prior('sigma',priors)),\n    \n    power.logistic = list(intercept = r.prior('intercept',priors), \n                          base= r.prior('base',priors), \n                          rate= - r.prior('rate',priors),\n                          upper.proportion = r.prior('upper.proportion',priors), \n                          lower.proportion = r.prior('lower.proportion',priors), \n                          rate.1= -r.prior('rate',priors),\n                          split = r.prior('split',priors),\n                          sigma=r.prior('sigma',priors)) )\n  return(recovery.parameter.values)\n}\n\n\nadd.noise<-function(recover,sigma){\n  n<-length(recover)\n  recover.plus.noise<-numeric()\n  for(i in 1:n){\n    noise<-rnorm(1, 0, sigma)\n    val<-recover[i]\n    while(abs(val)<= abs(noise)){\n      noise<-rnorm(1,0,sigma)\n    }\n    recover.plus.noise[i]<-val+noise\n  }\n  return(recover.plus.noise)\n}\n\n\ncreate.recovery.data<-function(par, t, models= c('power.constant',\n                                                'power.logistic',\n                                                'power.power',\n                                                'piecewise.power.constant')){\n\n  \n  \n  for(m in models){\n    \n    \n    \n    \n    if(m == 'power.constant'){\n      params<-model.params(par, 'power.constant')\n      rtu<-mapply(u.power.model.predict,t, MoreArgs = list(params[1],params[2],params[3]))\n      rl<-mapply(rl.constant.model.predict,t,MoreArgs= list(params[4]))\n      rtp<-rl*rtu\n      power.constant.recover.u<-add.noise(rtu,params[5])\n      power.constant.recover.p<-add.noise(rtp,params[5])\n    }\n\n    if(m == 'power.logistic'){\n      params<-model.params(par, 'power.logistic')\n      rtu<-mapply(u.power.model.predict,t,MoreArgs = list(params[1],params[2],params[3]))\n      rl<-mapply(rl.logistic.model.predict,t,MoreArgs = list(params[4],params[5],params[6],params[7]))\n      rtp<-rl*rtu\n      power.logistic.recover.u<-add.noise(rtu,params[8])\n      power.logistic.recover.p<-add.noise(rtp,params[8])\n    }\n\n    if(m == 'power.power'){\n      params<-model.params(par, 'power.power')\n      rtu<-mapply(u.power.model.predict,t,MoreArgs = list(params[1],params[2],params[3]))\n      rl<-mapply(rl.power.model.predict,t,MoreArgs = list(params[4],params[5],params[6]))\n      rtp<-rl*rtu\n      power.power.recover.u<-add.noise(rtu,params[7])\n      power.power.recover.p<-add.noise(rtp,params[7])\n    }\n    if(m == 'piecewise.power.constant'){\n      params<-model.params(par, 'piecewise.power.constant')\n      t1<-head(t,params[6])\n      t2<-tail(t,-params[6])\n      \n      print(params)\n      \n      rtu<-mapply(u.power.model.predict,t,MoreArgs = list(params[1],params[2],params[3]))\n      rl1<-mapply(rl.constant.model.predict,t1,MoreArgs = list(params[4]))\n      rl2<-mapply(rl.constant.model.predict,t2,MoreArgs = list(params[5]))\n      rtp[t1]<-rl1*rtu[t1]\n      rtp[t2]<-rl2*rtu[t2]\n      piecewise.power.constant.recover.u<-add.noise(rtu,params[7])\n      piecewise.power.constant.recover.p<-add.noise(rtp,params[7])\n    }\n  }\n  \n  \n  recovery.data<-expand.grid(t=1:72, model= c( 'power.constant',\n                                               'power.logistic',\n                                               'power.power',\n                                               'piecewise.power.constant'))\n  \n  recovery.data$predictable<-c(\n    power.constant.recover.p,\n    power.logistic.recover.p,\n    power.power.recover.p,\n    piecewise.power.constant.recover.p)\n  \n  recovery.data$unpredictable<-c(\n    power.constant.recover.u,\n    power.logistic.recover.u,\n    power.power.recover.u,\n    piecewise.power.constant.recover.u)\n  \n  return(recovery.data)  \n}\n\nparams<-generate.parameter.values(priors)\ndata.recover<-create.recovery.data(params)\nsubset(data.recover,model=='power.power')\n\nplot.data.fits(subject.data=subset(data.recover,model=='power.power'))\n",
    "created" : 1498743612335.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4093088204",
    "id" : "E0317232",
    "lastKnownWriteTime" : 1498760155,
    "last_content_update" : 1498760155735,
    "path" : "~/shape_sl_hierarchical_models/make_data.R",
    "project_path" : "make_data.R",
    "properties" : {
        "tempName" : "Untitled3"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}